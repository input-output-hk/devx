name: Prebuild DevX closures
on:
  push:

  workflow_dispatch:

env:
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}
  DEFAULT_TAG: latest
  GH_TOKEN: ${{ github.token }}

jobs:
  # wait-for-hydra-eval:
  #   env:
  #     GH_TOKEN: ${{ github.token }}
  #   name: "Wait for hydra status"
  #   runs-on: ubuntu-latest
  #   steps:
  #   - uses: input-output-hk/actions/wait-for-hydra@latest
  #     with:
  #       check: required

  discover:
    # needs: wait-for-hydra-eval
    name: Discover
    runs-on: ubuntu-latest
    outputs:
      matrix: ${{ steps.set-matrix.outputs.matrix }}
    steps:
    - name: fetch all ci/hydra-build jobs
      id: set-matrix
      run: |
        # Group the output by platform.
        RUNS=$(gh api "repos/$GITHUB_REPOSITORY/commits/2c66429a549f1122374faf3e1eb097e07a8f0c22/check-runs" --paginate)
        echo "checks..."
        FILTERED=$(jq -c -r '.check_runs[] | select(.name | endswith("-env")) |  { "config": .name, "build_path": .output.text }' <<< "$RUNS")
        jq . <<< "$FILTERED"
        MATRIX=$(jq --slurp -c -r '. as $jobs | map(.config | split(".") | first) | unique | map(. as $group | {"platform": $group, "jobs": $jobs | map(select(.config |startswith($group)))})' <<< "$FILTERED")
        jq . <<< "$MATRIX"
        echo "creating result matrix."
        echo "matrix=$MATRIX" >> $GITHUB_OUTPUT

  # We need this process step in here, because we have in excess of 256 jobs.
  process:
    needs: discover
    runs-on: ubuntu-latest # You still need runs-on to define a job, but it can be minimal
    strategy:
      fail-fast: false
      matrix:
        group: ${{ fromJson(needs.discover.outputs.matrix) }}
    name: Process Jobs for ${{ matrix.group.platform }}
    steps:
      - name: Call Container Upload Workflow
        uses: actions/github-script@v6
        with:
          script: |
            const matrix = JSON.parse('${{ toJson(matrix) }}'};
            const platform = matrix.group.platform;
            const jobs = matrix.group.jobs;
            console.log(`Calling container-upload workflow for platform: ${platform} with ${jobs.length} jobs`);

            await github.rest.actions.createWorkflowDispatch({
              owner: context.repo.owner,
              repo: context.repo.repo,
              workflow_id: 'container-upload.yml', // Filename of the reusable workflow
              ref: context.ref, // Or specify a branch/tag
              inputs: {
                platform: platform,
                jobs: JSON.stringify(jobs) // Pass jobs as JSON string
              }
            });
    
  # codespace-upload:
  #   env:
  #     IMAGE_NAME: input-output-hk/devx-devcontainer
  #   needs: ghcr-upload
  #   permissions:
  #     packages: write
  #   runs-on: ubuntu-latest
  #   # We want a GitHub Codespace image for each combination of devx developer shell option.
  #   # But, since the purpose of GitHub Codespace is to serve a complete development environment,
  #   # the user is likely to always expect HLS (I don't see the point otherwise).
  #   # Therefore, it doesn't seem useful to build an image on the `-minimal` flavor (without HLS),
  #   # or the `-static` one (especially since the latter currently requires `-minimal` to work).
  #   # Likely, we consider using `-iog` as the default and do not generate other images.
  #   # Then the user choices left would be between native, `-windows` or `-js` target platforms,
  #   # and the GHC version (currently `ghc810` and `ghc96`).
  #   if: false
  #   steps:
  #     - name: Checkout repository
  #       uses: actions/checkout@v4

  #     - name: Log in to the Container registry
  #       uses: docker/login-action@v2.1.0
  #       with:
  #         registry: ${{ env.REGISTRY }}
  #         username: ${{ github.actor }}
  #         password: ${{ secrets.GITHUB_TOKEN }}

  #     - name: Build and push Docker image
  #       uses: docker/build-push-action@v4
  #       with:
  #         context: .
  #         push: true
  #         tags: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ inputs.platform }}.${{ inputs.compiler-nix-name }}${{ inputs.target-platform }}${{ inputs.variant }}${{ inputs.iog }}
  #         build-args: |
  #           PLATFORM=${{ inputs.platform }}
  #           TARGET_PLATFORM=${{ inputs.target-platform }}
  #           COMPILER_NIX_NAME=${{ inputs.compiler-nix-name }}
  #           VARIANT=${{ inputs.variant }}
  #           IOG=${{ inputs.iog }}

  #     - name: Run test command inside the Dev Container
  #       run: |
  #         docker run --rm ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ inputs.platform }}.${{ inputs.compiler-nix-name }}${{ inputs.target-platform }}${{ inputs.variant }}${{ inputs.iog }} \
  #         bash -ic "cabal update && cabal unpack hello && cd hello-* && cabal build"
